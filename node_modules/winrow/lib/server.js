'use strict';

const Promise = require('bluebird');
const lodash = require('lodash');
const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const process = require('process');
const express = require('express');
const app = express();
const router = express.Router();
const logger = require('morgan');
const mongoose = require('mongoose');
const cors = require('cors');
const bodyParser = require('body-parser');
const jwt = require('jsonwebtoken');
const moment = require('moment');
const momentTimezone = require('moment-timezone');
const slugifyString = require('../config/utils/slugifyString');
const returnCodes = require('../config/utils/returnCodes');
const validator = require('../config/utils/validator');
const getRequestId = require('../config/utils/getRequestId');
const loggingFactory = require('winrow-logger');
const { get, isFunction } = lodash;
const { name, version } = require('../package.json');

function Server() {
  // create server
  let server = http.createServer(app);
  // get Promise
  this.Promise = Promise;
  // get Lodash
  this.lodash = lodash;
  // get mongoose
  this.mongoose = mongoose;
  // global Promise
  mongoose.Promise = global.Promise;
  mongoose.set("debug", true);
  // get moment
  this.moment = moment;
  this.momentTimezone = momentTimezone;
  // get slug
  this.slugifyString = slugifyString;
  // get returnCodes
  this.returnCodes = returnCodes;
  // get validator
  this.validator = validator;
  // get requestId
  this.getRequestId = getRequestId;
  const requestId = getRequestId();
  // get jsonwebtoken
  this.jwt = jwt;
  //get app
  this.app = app;
  //get router
  this.router = router;
  // get express
  this.express = express;
  app.use(logger('dev'));
  // connect ui
  app.use(cors());
  app.use(bodyParser.json({ limit: '100mb' }));
  app.use(bodyParser.urlencoded({ limit: '100mb', extended: true }));
  app.use(express.static(path.join(__dirname, 'build')));
  app.use('/rest/api/images', express.static('images'));
  const options = {
    key: fs.readFileSync(path.resolve(__dirname, '../config/data', 'key.pem')),
    cert: fs.readFileSync(path.resolve(__dirname, '../config/data', 'cert.pem'))
  }
  // start server
  this.start = function (sandbox) {
    const enable = get(sandbox, 'application.enable');
    const data_ssl = get(sandbox, 'application.data_ssl');
    const pathServer = get(sandbox, 'application.pathServer');
    const protocol = enable ? process.env.PROTOCOL || 'https' : 'http';
    const portHttp = enable ? process.env.PORT || get(data_ssl, 'port') : 8080;
    const hostHttp = enable ? process.env.HOST || get(data_ssl, 'host') : '0.0.0.0';
    if (enable) {
      server = https.createServer(options, app);
    }
    return new Promise((resolve, reject) => {
      const serverInstance = server.listen(portHttp, hostHttp, (err) => {
        if (err) {
          loggingFactory.error(`Start server has error :${err}`, {
            labelName: `[${name}]`,
            requestId: `${requestId}`
          })
          reject(err);
        }
        const port = serverInstance.address().port;
        const host = serverInstance.address().address;
        console.info('The server is running on %s://%s:%s', protocol, host, port);
        loggingFactory.debug(`Path server : ${pathServer}`, {
          labelName: `[${name}]`,
          requestId: `${requestId}`
        });
        loggingFactory.info(`The server start with: ${protocol}://${host}:${port}${pathServer}`, {
          labelName: `[${name}]`,
          requestId: `${requestId}`
        });
      })
      resolve(serverInstance)
    })
      .then(info => {
        loggingFactory.data(`Connect with library ${name} version : ${version} has complete`, {
          labelName: `[${name}]`,
          requestId: `${requestId}`
        });
        return info
      })
      .catch(err => {
        loggingFactory.warn(`Start server has error : ${err}`, {
          labelName: `[${name}]`,
          requestId: `${requestId}`
        })
        return Promise.reject(err);
      })
  };
  // stop server
  this.stop = function () {
    return new Promise(function (resolve, reject) {
      const timeOut = setTimeout(function () {
        reject();
      }, 3000);
      const serverClose = function () {
        if (server && isFunction(serverClose)) {
          server.removeListener('close', serverClose)
        }
      }

      server.on('close', serverClose)
      server.close(function (err) {
        clearTimeout(timeOut)
        resolve(err);
      });
      loggingFactory.warn(`Disconnect library ${name} version : ${version}`, {
        labelName: `[${name}]`,
        requestId: `${requestId}`
      });
    })
      .then(() => {
        process.exit(0);
      })
      .catch(err => {
        loggingFactory.error(`The Server Stop Has Error : ${err}`, {
          labelName: `[${name}]`,
          requestId: `${requestId}`
        });
        return Promise.reject(err)
      })
  };
};

module.exports = new Server();